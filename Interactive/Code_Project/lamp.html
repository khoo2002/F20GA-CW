<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Load OBJ File</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
        "three/examples/jsm/loaders/OBJLoader": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/OBJLoader.js",
        "three/examples/jsm/loaders/MTLLoader": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/MTLLoader.js",
        "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';
    import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    document.body.appendChild(renderer.domElement);

    camera.position.set(16, 2, -0.25); // Place camera at (5, 5, 5)
    camera.lookAt(0, 0, 0);       // Point it toward the origin (0, 0, 0)
    camera.rotation.set(0, 0, 0); // Set the camera's rotation to 0

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let moveZ = 4;
    let showHelper = false;

    // scene.background = new THREE.Color( 0xe0e0e0 );
    // scene.fog = new THREE.Fog( 0xe0e0e0, 20, 100 );
    // lights

    const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 1 );
    hemiLight.position.set( 0, 20, 30 );
    scene.add( hemiLight );

    const dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
    dirLight.position.set( 0, 20, 10 );
    scene.add( dirLight );

    // ground

    const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0xcbcbcb, depthWrite: false } ) );
    mesh.rotation.x = - Math.PI / 2;
    scene.add( mesh );

    const grid = new THREE.GridHelper( 200, 40, 0x000000, 0x000000 );
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    scene.add( grid );
    // // Add lighting
    // const light = new THREE.DirectionalLight(0xffffff, 2);
    // light.position.set(100, (100+moveZ), 100).normalize();
    // scene.add(light);


    const bulbLight = new THREE.PointLight(0xFFFD37, 30, 0);
    bulbLight.position.set(0, (2+moveZ), 0);
    scene.add(bulbLight);
    if(showHelper){
      const helper = new THREE.PointLightHelper(bulbLight);
      scene.add(helper);
    }

    // Array to store all loaded objects
    let chainLeft;
    let chainRight;
    let lamp;
    let pendant;
    let _switch;

    let loadedObjects = {
      chainLeft: null,
      chainRight: null,
      lamp: null,
      pendant: null,
      _switch: null
    };
    let scale = 0.9;

  // Assuming loadObject is a function that returns a Promise
  function loadObject(objPath, mtlPath, initialPosition, scale, color) {
    return new Promise((resolve, reject) => {
      if(objPath === 'meshes/chain.obj'){
          const material = new THREE.MeshPhysicalMaterial({  
            metalness: 1.0,
            roughness: 0.4,
            ambientIntensity: 0.2,
            aoMapIntensity: 1.0,
            envMapIntensity: 1.0,
            displacementScale: 2.436143, // from original model
            normalScale: 1.0,
          });
          const objLoader = new OBJLoader();
          // objLoader.setMaterials(material);
          objLoader.load(objPath, (object) => {
            object.position.copy(initialPosition);
            object.scale.set(scale, scale, scale);
            if(showHelper){
              const boxHelper = new THREE.BoxHelper(object, color);
              scene.add(boxHelper);
            }
            object.traverse((child) => {
              if (child.isMesh) {
                child.material = material;  // Apply custom material to each mesh in the object
              }
            });
            // if (color) {
            //   object.traverse((child) => {
            //     if (child.isMesh) {
            //       child.material.color.set(color);
            //     }
            //   });
            // }
            scene.add(object);
            resolve(object);
          }, undefined, reject);
      }else if(objPath === 'meshes/pendant.obj'){
        const material = new THREE.MeshPhysicalMaterial({  
          color: 0xffffff,
          transmission: 0.93,
          opacity: 1,
          metalness: 0,
          roughness: 0,
          ior: 4,
          thickness: 1,
          specularIntensity: 1,
          specularColor: 0xffffff,
          envMapIntensity: 1,
          lightIntensity: 1,
          exposure: 1
        });
        const objLoader = new OBJLoader();
        // objLoader.setMaterials(material);
        objLoader.load(objPath, (object) => {
          object.position.copy(initialPosition);
          object.scale.set(scale, scale, scale);
          if(showHelper){
              const boxHelper = new THREE.BoxHelper(object, color);
              scene.add(boxHelper);
          }
          object.traverse((child) => {
            if (child.isMesh) {
              child.material = material;  // Apply custom material to each mesh in the object
            }
          });
          // if (color) {
          //   object.traverse((child) => {
          //     if (child.isMesh) {
          //       child.material.color.set(color);
          //     }
          //   });
          // }
          scene.add(object);
          resolve(object);
        }, undefined, reject);
      }else{
        const mtlLoader = new MTLLoader();
        mtlLoader.load(mtlPath, (materials) => {
        materials.preload();

          // Map the materials for better PBR setup
          // Iterate through the materials object and apply changes
        Object.values(materials.materials).forEach((material) => {
          // Convert the material to MeshPhysicalMaterial for better realism
          material.metalness = material.metallic || 0;  // Blender metallic maps to Three.js metalness
          material.roughness = material.roughness || 0.5;  // Blender roughness maps to Three.js roughness

          // If there are texture maps (e.g., diffuse, specular, normal maps), load them
          if (material.map) {
            material.map = new THREE.TextureLoader().load(material.map);
          }
          if (material.normalMap) {
            material.normalMap = new THREE.TextureLoader().load(material.normalMap);
          }
          if (material.roughnessMap) {
            material.roughnessMap = new THREE.TextureLoader().load(material.roughnessMap);
          }
          if (material.metalnessMap) {
            material.metalnessMap = new THREE.TextureLoader().load(material.metalnessMap);
          }

          // Set up the material to be more realistic
          material.envMap = scene.background; // Use the scene's background as an environment map
          material.envMapIntensity = 1;  // Adjust the reflection intensity
          material.needsUpdate = true;  // Force Three.js to reapply material changes
        });

        const objLoader = new OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.load(objPath, (object) => {
          object.position.copy(initialPosition);
          object.scale.set(scale, scale, scale);
          if(showHelper){
              const boxHelper = new THREE.BoxHelper(object, color);
              scene.add(boxHelper);
          }
          let k = 1;
          if (color && objPath === 'meshes/lamp.obj') {
            object.traverse((child) => {

              if (child.isMesh && k == 1) {
                child.material.color.set("#DBA067");
                k++;
              }
            });
          }
          scene.add(object);
          resolve(object);
        }, undefined, reject);
      }, undefined, reject);
    }});
  
  }
    // Load objects and assign them to the loadedObjects object
    loadObject('meshes/lamp.obj', 'meshes/lamp.mtl',
     new THREE.Vector3(0*scale, (2.8*scale)+moveZ, 0*scale), scale, 0xff0000)
      .then(object => loadedObjects.lamp = object);

    //left chain
    loadObject('meshes/chain.obj', 'meshes/chain.mtl',
     new THREE.Vector3(0*scale, (7.78*scale)+moveZ, 1.25*scale), scale, 0x00ff00)
      .then(object => loadedObjects.chainRight = object);

    //right chain
    loadObject('meshes/chain.obj', 'meshes/chain.mtl',
     new THREE.Vector3(0*scale, (7.78*scale)+moveZ, -1.2*scale), scale, 0x0000ff)
      .then(object => loadedObjects.chainLeft = object);

    loadObject('meshes/pendant.obj', 'meshes/pendant.mtl',
     new THREE.Vector3(0*scale, (0*scale)+moveZ, 0*scale), scale, 0xffff00)
      .then(object => loadedObjects.pendant = object);

    loadObject('meshes/switch.obj', 'meshes/switch.mtl',
     new THREE.Vector3(0*scale, (1*scale)+moveZ, -1.0*scale), scale, 0xff00ff)
      .then(object => loadedObjects._switch = object);

    // Track the cursor position
    let cursorX = 0;
    let cursorY = 0;

    window.addEventListener('mousemove', (event) => {
      // Normalize cursor position to range [-1, 1] for both X and Y
      cursorX = (event.clientX / window.innerWidth) * 2 - 1;
      cursorY = -(event.clientY / window.innerHeight) * 2 + 1;
      
    });
    
    // Add OrbitControls for camera interaction
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.maxPolarAngle = Math.PI / 2;

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      controls.update(); // Only required if controls.enableDamping = true, or if controls.auto-rotation is enabled

      // scene.rotation.y += cursorX * 0.05; // Rotate around the Y-axis
      // scene.rotation.x += cursorY * 0.05; // Rotate around the X-axis

      // Iterate over each object in the loadedObjects object
      // Object.values(loadedObjects).forEach((object) => {
      //   if (object) {
      //     // Adjust the rotation of each object based on the cursor position
      //     object.rotation.x += cursorY * 0.05; // Rotate around the x-axis
      //     object.rotation.y += cursorX * 0.05; // Rotate around the y-axis

      //     // Optional: Log the rotation to verify it is happening
      //     // console.log(`Object rotation: x=${object.rotation.x.toFixed(2)}, y=${object.rotation.y.toFixed(2)}, z=${object.rotation.z.toFixed(2)}`);
      //   }
      // });
      console.log("Camera at: ", camera.position);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>